name: Gemini Summarize (spec analysis & structuring)
on:
  issues:
    types: [opened, edited, labeled]

permissions:
  issues: write

jobs:
  summarize:
    if: >
      (github.event.action == 'labeled' && github.event.label.name == 'spec-draft') ||
      (github.event.action != 'labeled' && contains(github.event.issue.labels.*.name, 'spec-draft'))
    runs-on: ubuntu-latest
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GEMINI_MODEL: gemini-1.5-pro
    steps:
      - name: Dump event (debug)
        run: |
          echo "EVENT=${GITHUB_EVENT_NAME}"
          jq . < "$GITHUB_EVENT_PATH" || true

      - name: Guard - API key
        run: |
          if [ -z "${GEMINI_API_KEY:-}" ]; then
            echo "No GEMINI_API_KEY; skipping summarization." && exit 0
          fi

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Build spec content
        run: |
          printf "%s\n\n%s\n" "${{ github.event.issue.title }}" "${{ github.event.issue.body }}" > spec.txt
          cat > prompt.txt << 'EOF'
          You are a technical product manager. Analyze this spec and return ONLY a structured JSON summary:

          ** REQUIRED JSON SCHEMA **
          {
            "project_name": string,
            "timeline": string,
            "executive_summary": string,
            "goals": {
              "primary": string,
              "metrics": [string]
            },
            "target_audience": {
              "b2c": string,
              "b2b": string
            },
            "channels": [string],
            "budget": {
              "total": string,
              "allocation": object
            },
            "deliverables": [string],
            "risks": [string],
            "tech_stack": [string],
            "priority_level": "high" | "medium" | "low"
          }

          Focus on extracting key business requirements, technical constraints, and success metrics. Be concise but comprehensive.
          EOF

      - name: Call Gemini API
        run: |
          # Debug: Show input content
          echo "=== SPEC CONTENT ==="
          cat spec.txt
          echo "=== PROMPT CONTENT ==="
          cat prompt.txt
          
          # Create JSON payload
          jq -n --arg prompt "$(cat prompt.txt)" --arg spec "$(cat spec.txt)" '{
            "contents": [{
              "parts": [{
                "text": ($prompt + "\n\nSPEC TO ANALYZE:\n" + $spec)
              }]
            }],
            "generationConfig": {
              "temperature": 0.3,
              "maxOutputTokens": 2000
            }
          }' > payload.json
          
          echo "=== API PAYLOAD ==="
          cat payload.json
          
          # Call Gemini API
          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @payload.json > gemini.json
          
          echo "=== GEMINI RESPONSE ==="
          cat gemini.json
          
          # Check for API errors and extract content with comprehensive fallback
          if jq -e '.error' gemini.json > /dev/null; then
            echo "Gemini API Error (using fallback):"
            jq '.error' gemini.json
            echo '{"project_name":"API Error - Fallback Analysis","timeline":"TBD","executive_summary":"Gemini API quota exceeded, using fallback","priority_level":"medium","note":"Generated via fallback due to API limits"}' > summary.txt
          elif jq -e '.candidates[0].content.parts[0].text' gemini.json > /dev/null; then
            echo "Successful API response, extracting content"
            jq -r '.candidates[0].content.parts[0].text' gemini.json > summary.txt
          else
            echo "No valid response from Gemini, using fallback"
            echo '{"project_name":"Fallback Analysis","timeline":"TBD","executive_summary":"Auto-generated fallback","priority_level":"medium"}' > summary.txt
          fi
          
          echo "=== EXTRACTED TEXT ==="
          cat summary.txt
          
          # Extract JSON from the response (handle markdown code blocks)
          if grep -q '```json' summary.txt; then
            sed -n '/```json/,/```/p' summary.txt | sed '1d;$d' > summary.json
          elif grep -q '{' summary.txt; then
            # Try to extract JSON directly
            cat summary.txt > summary.json
          else
            echo "No JSON found in response, using fallback"
            cp summary.txt summary.json
          fi
          
          # Validate JSON
          if ! jq . summary.json > /dev/null; then
            echo "Invalid JSON, using summary.txt as raw content"
            jq -R -s '{raw_analysis: .}' summary.txt > summary.json
          fi
          
          echo "=== FINAL JSON ==="
          cat summary.json

      - name: Post summary comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cat > comment.md << 'EOF'
          ## ðŸ“Š Gemini Analysis Summary

          **Spec Analysis Complete** âœ…

          ```json
          EOF
          cat summary.json >> comment.md
          cat >> comment.md << 'EOF'
          ```

          ---
          *Next: Claude will generate tasks based on this summary*
          ðŸ¤– Ready for `needs-plan` label to trigger Claude Autoplan
          EOF
          
          jq -Rs --arg b "$(cat comment.md)" '{"body":$b}' <<< "" > body.json
          curl -sS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            -d @body.json \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments"

      - name: Add needs-plan label
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          curl -sS -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            -X POST \
            -d '{"labels":["needs-plan"]}' \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/labels"